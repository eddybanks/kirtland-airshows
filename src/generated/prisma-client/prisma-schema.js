module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.30.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Address {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  address_line: String!
  address_line_two: String
  zipcode: String!
  city: String!
  state: String!
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  address_line: String!
  address_line_two: String
  zipcode: String!
  city: String!
  state: String!
}

input AddressCreateManyInput {
  create: [AddressCreateInput!]
  connect: [AddressWhereUniqueInput!]
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  address_line_ASC
  address_line_DESC
  address_line_two_ASC
  address_line_two_DESC
  zipcode_ASC
  zipcode_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
}

type AddressPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  address_line: String!
  address_line_two: String
  zipcode: String!
  city: String!
  state: String!
}

input AddressScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  address_line: String
  address_line_not: String
  address_line_in: [String!]
  address_line_not_in: [String!]
  address_line_lt: String
  address_line_lte: String
  address_line_gt: String
  address_line_gte: String
  address_line_contains: String
  address_line_not_contains: String
  address_line_starts_with: String
  address_line_not_starts_with: String
  address_line_ends_with: String
  address_line_not_ends_with: String
  address_line_two: String
  address_line_two_not: String
  address_line_two_in: [String!]
  address_line_two_not_in: [String!]
  address_line_two_lt: String
  address_line_two_lte: String
  address_line_two_gt: String
  address_line_two_gte: String
  address_line_two_contains: String
  address_line_two_not_contains: String
  address_line_two_starts_with: String
  address_line_two_not_starts_with: String
  address_line_two_ends_with: String
  address_line_two_not_ends_with: String
  zipcode: String
  zipcode_not: String
  zipcode_in: [String!]
  zipcode_not_in: [String!]
  zipcode_lt: String
  zipcode_lte: String
  zipcode_gt: String
  zipcode_gte: String
  zipcode_contains: String
  zipcode_not_contains: String
  zipcode_starts_with: String
  zipcode_not_starts_with: String
  zipcode_ends_with: String
  zipcode_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  AND: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  NOT: [AddressScalarWhereInput!]
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
}

input AddressUpdateDataInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  address_line: String
  address_line_two: String
  zipcode: String
  city: String
  state: String
}

input AddressUpdateInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  address_line: String
  address_line_two: String
  zipcode: String
  city: String
  state: String
}

input AddressUpdateManyDataInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  address_line: String
  address_line_two: String
  zipcode: String
  city: String
  state: String
}

input AddressUpdateManyInput {
  create: [AddressCreateInput!]
  update: [AddressUpdateWithWhereUniqueNestedInput!]
  upsert: [AddressUpsertWithWhereUniqueNestedInput!]
  delete: [AddressWhereUniqueInput!]
  connect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  disconnect: [AddressWhereUniqueInput!]
  deleteMany: [AddressScalarWhereInput!]
  updateMany: [AddressUpdateManyWithWhereNestedInput!]
}

input AddressUpdateManyMutationInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  address_line: String
  address_line_two: String
  zipcode: String
  city: String
  state: String
}

input AddressUpdateManyWithWhereNestedInput {
  where: AddressScalarWhereInput!
  data: AddressUpdateManyDataInput!
}

input AddressUpdateWithWhereUniqueNestedInput {
  where: AddressWhereUniqueInput!
  data: AddressUpdateDataInput!
}

input AddressUpsertWithWhereUniqueNestedInput {
  where: AddressWhereUniqueInput!
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  address_line: String
  address_line_not: String
  address_line_in: [String!]
  address_line_not_in: [String!]
  address_line_lt: String
  address_line_lte: String
  address_line_gt: String
  address_line_gte: String
  address_line_contains: String
  address_line_not_contains: String
  address_line_starts_with: String
  address_line_not_starts_with: String
  address_line_ends_with: String
  address_line_not_ends_with: String
  address_line_two: String
  address_line_two_not: String
  address_line_two_in: [String!]
  address_line_two_not_in: [String!]
  address_line_two_lt: String
  address_line_two_lte: String
  address_line_two_gt: String
  address_line_two_gte: String
  address_line_two_contains: String
  address_line_two_not_contains: String
  address_line_two_starts_with: String
  address_line_two_not_starts_with: String
  address_line_two_ends_with: String
  address_line_two_not_ends_with: String
  zipcode: String
  zipcode_not: String
  zipcode_in: [String!]
  zipcode_not_in: [String!]
  zipcode_lt: String
  zipcode_lte: String
  zipcode_gt: String
  zipcode_gte: String
  zipcode_contains: String
  zipcode_not_contains: String
  zipcode_starts_with: String
  zipcode_not_starts_with: String
  zipcode_ends_with: String
  zipcode_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  AND: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateAirshow {
  count: Int!
}

type AggregateParkingLot {
  count: Int!
}

type AggregateTracking {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateZone {
  count: Int!
}

type Airshow {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  date: String!
}

type AirshowConnection {
  pageInfo: PageInfo!
  edges: [AirshowEdge]!
  aggregate: AggregateAirshow!
}

input AirshowCreateInput {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  date: String!
}

input AirshowCreateOneInput {
  create: AirshowCreateInput
  connect: AirshowWhereUniqueInput
}

type AirshowEdge {
  node: Airshow!
  cursor: String!
}

enum AirshowOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  date_ASC
  date_DESC
}

type AirshowPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  date: String!
}

type AirshowSubscriptionPayload {
  mutation: MutationType!
  node: Airshow
  updatedFields: [String!]
  previousValues: AirshowPreviousValues
}

input AirshowSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AirshowWhereInput
  AND: [AirshowSubscriptionWhereInput!]
}

input AirshowUpdateDataInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  date: String
}

input AirshowUpdateInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  date: String
}

input AirshowUpdateManyMutationInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  date: String
}

input AirshowUpdateOneRequiredInput {
  create: AirshowCreateInput
  update: AirshowUpdateDataInput
  upsert: AirshowUpsertNestedInput
  connect: AirshowWhereUniqueInput
}

input AirshowUpsertNestedInput {
  update: AirshowUpdateDataInput!
  create: AirshowCreateInput!
}

input AirshowWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  AND: [AirshowWhereInput!]
}

input AirshowWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createAirshow(data: AirshowCreateInput!): Airshow!
  updateAirshow(data: AirshowUpdateInput!, where: AirshowWhereUniqueInput!): Airshow
  updateManyAirshows(data: AirshowUpdateManyMutationInput!, where: AirshowWhereInput): BatchPayload!
  upsertAirshow(where: AirshowWhereUniqueInput!, create: AirshowCreateInput!, update: AirshowUpdateInput!): Airshow!
  deleteAirshow(where: AirshowWhereUniqueInput!): Airshow
  deleteManyAirshows(where: AirshowWhereInput): BatchPayload!
  createParkingLot(data: ParkingLotCreateInput!): ParkingLot!
  updateParkingLot(data: ParkingLotUpdateInput!, where: ParkingLotWhereUniqueInput!): ParkingLot
  updateManyParkingLots(data: ParkingLotUpdateManyMutationInput!, where: ParkingLotWhereInput): BatchPayload!
  upsertParkingLot(where: ParkingLotWhereUniqueInput!, create: ParkingLotCreateInput!, update: ParkingLotUpdateInput!): ParkingLot!
  deleteParkingLot(where: ParkingLotWhereUniqueInput!): ParkingLot
  deleteManyParkingLots(where: ParkingLotWhereInput): BatchPayload!
  createTracking(data: TrackingCreateInput!): Tracking!
  updateTracking(data: TrackingUpdateInput!, where: TrackingWhereUniqueInput!): Tracking
  updateManyTrackings(data: TrackingUpdateManyMutationInput!, where: TrackingWhereInput): BatchPayload!
  upsertTracking(where: TrackingWhereUniqueInput!, create: TrackingCreateInput!, update: TrackingUpdateInput!): Tracking!
  deleteTracking(where: TrackingWhereUniqueInput!): Tracking
  deleteManyTrackings(where: TrackingWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createZone(data: ZoneCreateInput!): Zone!
  updateZone(data: ZoneUpdateInput!, where: ZoneWhereUniqueInput!): Zone
  updateManyZones(data: ZoneUpdateManyMutationInput!, where: ZoneWhereInput): BatchPayload!
  upsertZone(where: ZoneWhereUniqueInput!, create: ZoneCreateInput!, update: ZoneUpdateInput!): Zone!
  deleteZone(where: ZoneWhereUniqueInput!): Zone
  deleteManyZones(where: ZoneWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type ParkingLot {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  address(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address!]
  vehicle_capacity: Int!
  estimated_travel_distance: Int
  estimated_travel_time: Int
  zone: Zone!
}

type ParkingLotConnection {
  pageInfo: PageInfo!
  edges: [ParkingLotEdge]!
  aggregate: AggregateParkingLot!
}

input ParkingLotCreateInput {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  address: AddressCreateManyInput
  vehicle_capacity: Int!
  estimated_travel_distance: Int
  estimated_travel_time: Int
  zone: ZoneCreateOneInput!
}

input ParkingLotCreateOneInput {
  create: ParkingLotCreateInput
  connect: ParkingLotWhereUniqueInput
}

type ParkingLotEdge {
  node: ParkingLot!
  cursor: String!
}

enum ParkingLotOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  vehicle_capacity_ASC
  vehicle_capacity_DESC
  estimated_travel_distance_ASC
  estimated_travel_distance_DESC
  estimated_travel_time_ASC
  estimated_travel_time_DESC
}

type ParkingLotPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  vehicle_capacity: Int!
  estimated_travel_distance: Int
  estimated_travel_time: Int
}

type ParkingLotSubscriptionPayload {
  mutation: MutationType!
  node: ParkingLot
  updatedFields: [String!]
  previousValues: ParkingLotPreviousValues
}

input ParkingLotSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ParkingLotWhereInput
  AND: [ParkingLotSubscriptionWhereInput!]
}

input ParkingLotUpdateDataInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  address: AddressUpdateManyInput
  vehicle_capacity: Int
  estimated_travel_distance: Int
  estimated_travel_time: Int
  zone: ZoneUpdateOneRequiredInput
}

input ParkingLotUpdateInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  address: AddressUpdateManyInput
  vehicle_capacity: Int
  estimated_travel_distance: Int
  estimated_travel_time: Int
  zone: ZoneUpdateOneRequiredInput
}

input ParkingLotUpdateManyMutationInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  vehicle_capacity: Int
  estimated_travel_distance: Int
  estimated_travel_time: Int
}

input ParkingLotUpdateOneInput {
  create: ParkingLotCreateInput
  update: ParkingLotUpdateDataInput
  upsert: ParkingLotUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ParkingLotWhereUniqueInput
}

input ParkingLotUpsertNestedInput {
  update: ParkingLotUpdateDataInput!
  create: ParkingLotCreateInput!
}

input ParkingLotWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address_some: AddressWhereInput
  vehicle_capacity: Int
  vehicle_capacity_not: Int
  vehicle_capacity_in: [Int!]
  vehicle_capacity_not_in: [Int!]
  vehicle_capacity_lt: Int
  vehicle_capacity_lte: Int
  vehicle_capacity_gt: Int
  vehicle_capacity_gte: Int
  estimated_travel_distance: Int
  estimated_travel_distance_not: Int
  estimated_travel_distance_in: [Int!]
  estimated_travel_distance_not_in: [Int!]
  estimated_travel_distance_lt: Int
  estimated_travel_distance_lte: Int
  estimated_travel_distance_gt: Int
  estimated_travel_distance_gte: Int
  estimated_travel_time: Int
  estimated_travel_time_not: Int
  estimated_travel_time_in: [Int!]
  estimated_travel_time_not_in: [Int!]
  estimated_travel_time_lt: Int
  estimated_travel_time_lte: Int
  estimated_travel_time_gt: Int
  estimated_travel_time_gte: Int
  zone: ZoneWhereInput
  AND: [ParkingLotWhereInput!]
}

input ParkingLotWhereUniqueInput {
  id: ID
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  airshow(where: AirshowWhereUniqueInput!): Airshow
  airshows(where: AirshowWhereInput, orderBy: AirshowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Airshow]!
  airshowsConnection(where: AirshowWhereInput, orderBy: AirshowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AirshowConnection!
  parkingLot(where: ParkingLotWhereUniqueInput!): ParkingLot
  parkingLots(where: ParkingLotWhereInput, orderBy: ParkingLotOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ParkingLot]!
  parkingLotsConnection(where: ParkingLotWhereInput, orderBy: ParkingLotOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ParkingLotConnection!
  tracking(where: TrackingWhereUniqueInput!): Tracking
  trackings(where: TrackingWhereInput, orderBy: TrackingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tracking]!
  trackingsConnection(where: TrackingWhereInput, orderBy: TrackingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TrackingConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  zone(where: ZoneWhereUniqueInput!): Zone
  zones(where: ZoneWhereInput, orderBy: ZoneOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Zone]!
  zonesConnection(where: ZoneWhereInput, orderBy: ZoneOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ZoneConnection!
  node(id: ID!): Node
}

type Subscription {
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  airshow(where: AirshowSubscriptionWhereInput): AirshowSubscriptionPayload
  parkingLot(where: ParkingLotSubscriptionWhereInput): ParkingLotSubscriptionPayload
  tracking(where: TrackingSubscriptionWhereInput): TrackingSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  zone(where: ZoneSubscriptionWhereInput): ZoneSubscriptionPayload
}

type Tracking {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  airshow: Airshow!
  parking_lot: ParkingLot
  zone: Zone
  vehicle_count: Int!
  bus_count: Int!
  passenger_count: Int!
}

type TrackingConnection {
  pageInfo: PageInfo!
  edges: [TrackingEdge]!
  aggregate: AggregateTracking!
}

input TrackingCreateInput {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  airshow: AirshowCreateOneInput!
  parking_lot: ParkingLotCreateOneInput
  zone: ZoneCreateOneInput
  vehicle_count: Int!
  bus_count: Int!
  passenger_count: Int!
}

type TrackingEdge {
  node: Tracking!
  cursor: String!
}

enum TrackingOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  vehicle_count_ASC
  vehicle_count_DESC
  bus_count_ASC
  bus_count_DESC
  passenger_count_ASC
  passenger_count_DESC
}

type TrackingPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  vehicle_count: Int!
  bus_count: Int!
  passenger_count: Int!
}

type TrackingSubscriptionPayload {
  mutation: MutationType!
  node: Tracking
  updatedFields: [String!]
  previousValues: TrackingPreviousValues
}

input TrackingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TrackingWhereInput
  AND: [TrackingSubscriptionWhereInput!]
}

input TrackingUpdateInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  airshow: AirshowUpdateOneRequiredInput
  parking_lot: ParkingLotUpdateOneInput
  zone: ZoneUpdateOneInput
  vehicle_count: Int
  bus_count: Int
  passenger_count: Int
}

input TrackingUpdateManyMutationInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  vehicle_count: Int
  bus_count: Int
  passenger_count: Int
}

input TrackingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  airshow: AirshowWhereInput
  parking_lot: ParkingLotWhereInput
  zone: ZoneWhereInput
  vehicle_count: Int
  vehicle_count_not: Int
  vehicle_count_in: [Int!]
  vehicle_count_not_in: [Int!]
  vehicle_count_lt: Int
  vehicle_count_lte: Int
  vehicle_count_gt: Int
  vehicle_count_gte: Int
  bus_count: Int
  bus_count_not: Int
  bus_count_in: [Int!]
  bus_count_not_in: [Int!]
  bus_count_lt: Int
  bus_count_lte: Int
  bus_count_gt: Int
  bus_count_gte: Int
  passenger_count: Int
  passenger_count_not: Int
  passenger_count_in: [Int!]
  passenger_count_not_in: [Int!]
  passenger_count_lt: Int
  passenger_count_lte: Int
  passenger_count_gt: Int
  passenger_count_gte: Int
  AND: [TrackingWhereInput!]
}

input TrackingWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  id: ID
  name: String
  email: String
  password: String
}

input UserUpdateManyMutationInput {
  id: ID
  name: String
  email: String
  password: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

type Zone {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  lot_count: Int!
}

type ZoneConnection {
  pageInfo: PageInfo!
  edges: [ZoneEdge]!
  aggregate: AggregateZone!
}

input ZoneCreateInput {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  lot_count: Int!
}

input ZoneCreateOneInput {
  create: ZoneCreateInput
  connect: ZoneWhereUniqueInput
}

type ZoneEdge {
  node: Zone!
  cursor: String!
}

enum ZoneOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  lot_count_ASC
  lot_count_DESC
}

type ZonePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  lot_count: Int!
}

type ZoneSubscriptionPayload {
  mutation: MutationType!
  node: Zone
  updatedFields: [String!]
  previousValues: ZonePreviousValues
}

input ZoneSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ZoneWhereInput
  AND: [ZoneSubscriptionWhereInput!]
}

input ZoneUpdateDataInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  lot_count: Int
}

input ZoneUpdateInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  lot_count: Int
}

input ZoneUpdateManyMutationInput {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  lot_count: Int
}

input ZoneUpdateOneInput {
  create: ZoneCreateInput
  update: ZoneUpdateDataInput
  upsert: ZoneUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ZoneWhereUniqueInput
}

input ZoneUpdateOneRequiredInput {
  create: ZoneCreateInput
  update: ZoneUpdateDataInput
  upsert: ZoneUpsertNestedInput
  connect: ZoneWhereUniqueInput
}

input ZoneUpsertNestedInput {
  update: ZoneUpdateDataInput!
  create: ZoneCreateInput!
}

input ZoneWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  lot_count: Int
  lot_count_not: Int
  lot_count_in: [Int!]
  lot_count_not_in: [Int!]
  lot_count_lt: Int
  lot_count_lte: Int
  lot_count_gt: Int
  lot_count_gte: Int
  AND: [ZoneWhereInput!]
}

input ZoneWhereUniqueInput {
  id: ID
}
`
      }
    