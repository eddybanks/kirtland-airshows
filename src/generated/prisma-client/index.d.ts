// Code generated by Prisma (prisma@1.30.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  address: (where?: AddressWhereInput) => Promise<boolean>;
  airshow: (where?: AirshowWhereInput) => Promise<boolean>;
  parkingLot: (where?: ParkingLotWhereInput) => Promise<boolean>;
  tracking: (where?: TrackingWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  zone: (where?: ZoneWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  address: (where: AddressWhereUniqueInput) => AddressPromise;
  addresses: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Address>;
  addressesConnection: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AddressConnectionPromise;
  airshow: (where: AirshowWhereUniqueInput) => AirshowPromise;
  airshows: (
    args?: {
      where?: AirshowWhereInput;
      orderBy?: AirshowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Airshow>;
  airshowsConnection: (
    args?: {
      where?: AirshowWhereInput;
      orderBy?: AirshowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AirshowConnectionPromise;
  parkingLot: (where: ParkingLotWhereUniqueInput) => ParkingLotPromise;
  parkingLots: (
    args?: {
      where?: ParkingLotWhereInput;
      orderBy?: ParkingLotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ParkingLot>;
  parkingLotsConnection: (
    args?: {
      where?: ParkingLotWhereInput;
      orderBy?: ParkingLotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ParkingLotConnectionPromise;
  tracking: (where: TrackingWhereUniqueInput) => TrackingPromise;
  trackings: (
    args?: {
      where?: TrackingWhereInput;
      orderBy?: TrackingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tracking>;
  trackingsConnection: (
    args?: {
      where?: TrackingWhereInput;
      orderBy?: TrackingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TrackingConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  zone: (where: ZoneWhereUniqueInput) => ZonePromise;
  zones: (
    args?: {
      where?: ZoneWhereInput;
      orderBy?: ZoneOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Zone>;
  zonesConnection: (
    args?: {
      where?: ZoneWhereInput;
      orderBy?: ZoneOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ZoneConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (
    args: { data: AddressUpdateInput; where: AddressWhereUniqueInput }
  ) => AddressPromise;
  updateManyAddresses: (
    args: { data: AddressUpdateManyMutationInput; where?: AddressWhereInput }
  ) => BatchPayloadPromise;
  upsertAddress: (
    args: {
      where: AddressWhereUniqueInput;
      create: AddressCreateInput;
      update: AddressUpdateInput;
    }
  ) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createAirshow: (data: AirshowCreateInput) => AirshowPromise;
  updateAirshow: (
    args: { data: AirshowUpdateInput; where: AirshowWhereUniqueInput }
  ) => AirshowPromise;
  updateManyAirshows: (
    args: { data: AirshowUpdateManyMutationInput; where?: AirshowWhereInput }
  ) => BatchPayloadPromise;
  upsertAirshow: (
    args: {
      where: AirshowWhereUniqueInput;
      create: AirshowCreateInput;
      update: AirshowUpdateInput;
    }
  ) => AirshowPromise;
  deleteAirshow: (where: AirshowWhereUniqueInput) => AirshowPromise;
  deleteManyAirshows: (where?: AirshowWhereInput) => BatchPayloadPromise;
  createParkingLot: (data: ParkingLotCreateInput) => ParkingLotPromise;
  updateParkingLot: (
    args: { data: ParkingLotUpdateInput; where: ParkingLotWhereUniqueInput }
  ) => ParkingLotPromise;
  updateManyParkingLots: (
    args: {
      data: ParkingLotUpdateManyMutationInput;
      where?: ParkingLotWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertParkingLot: (
    args: {
      where: ParkingLotWhereUniqueInput;
      create: ParkingLotCreateInput;
      update: ParkingLotUpdateInput;
    }
  ) => ParkingLotPromise;
  deleteParkingLot: (where: ParkingLotWhereUniqueInput) => ParkingLotPromise;
  deleteManyParkingLots: (where?: ParkingLotWhereInput) => BatchPayloadPromise;
  createTracking: (data: TrackingCreateInput) => TrackingPromise;
  updateTracking: (
    args: { data: TrackingUpdateInput; where: TrackingWhereUniqueInput }
  ) => TrackingPromise;
  updateManyTrackings: (
    args: { data: TrackingUpdateManyMutationInput; where?: TrackingWhereInput }
  ) => BatchPayloadPromise;
  upsertTracking: (
    args: {
      where: TrackingWhereUniqueInput;
      create: TrackingCreateInput;
      update: TrackingUpdateInput;
    }
  ) => TrackingPromise;
  deleteTracking: (where: TrackingWhereUniqueInput) => TrackingPromise;
  deleteManyTrackings: (where?: TrackingWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createZone: (data: ZoneCreateInput) => ZonePromise;
  updateZone: (
    args: { data: ZoneUpdateInput; where: ZoneWhereUniqueInput }
  ) => ZonePromise;
  updateManyZones: (
    args: { data: ZoneUpdateManyMutationInput; where?: ZoneWhereInput }
  ) => BatchPayloadPromise;
  upsertZone: (
    args: {
      where: ZoneWhereUniqueInput;
      create: ZoneCreateInput;
      update: ZoneUpdateInput;
    }
  ) => ZonePromise;
  deleteZone: (where: ZoneWhereUniqueInput) => ZonePromise;
  deleteManyZones: (where?: ZoneWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  airshow: (
    where?: AirshowSubscriptionWhereInput
  ) => AirshowSubscriptionPayloadSubscription;
  parkingLot: (
    where?: ParkingLotSubscriptionWhereInput
  ) => ParkingLotSubscriptionPayloadSubscription;
  tracking: (
    where?: TrackingSubscriptionWhereInput
  ) => TrackingSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  zone: (
    where?: ZoneSubscriptionWhereInput
  ) => ZoneSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AirshowOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "date_ASC"
  | "date_DESC";

export type ParkingLotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "vehicle_capacity_ASC"
  | "vehicle_capacity_DESC"
  | "estimated_travel_distance_ASC"
  | "estimated_travel_distance_DESC"
  | "estimated_travel_time_ASC"
  | "estimated_travel_time_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "address_line_ASC"
  | "address_line_DESC"
  | "address_line_two_ASC"
  | "address_line_two_DESC"
  | "zipcode_ASC"
  | "zipcode_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC";

export type TrackingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "vehicle_count_ASC"
  | "vehicle_count_DESC"
  | "bus_count_ASC"
  | "bus_count_DESC"
  | "passenger_count_ASC"
  | "passenger_count_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type ZoneOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "lot_count_ASC"
  | "lot_count_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface AirshowCreateInput {
  id: ID_Input;
  createdAt: DateTimeInput;
  updatedAt: DateTimeInput;
  name: String;
  date: String;
}

export type AddressWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
}

export interface AddressUpsertWithWhereUniqueNestedInput {
  where: AddressWhereUniqueInput;
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface AirshowUpdateOneRequiredInput {
  create?: AirshowCreateInput;
  update?: AirshowUpdateDataInput;
  upsert?: AirshowUpsertNestedInput;
  connect?: AirshowWhereUniqueInput;
}

export interface ZoneCreateOneInput {
  create?: ZoneCreateInput;
  connect?: ZoneWhereUniqueInput;
}

export interface TrackingUpdateInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  airshow?: AirshowUpdateOneRequiredInput;
  parking_lot?: ParkingLotUpdateOneInput;
  zone?: ZoneUpdateOneInput;
  vehicle_count?: Int;
  bus_count?: Int;
  passenger_count?: Int;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ParkingLotCreateOneInput {
  create?: ParkingLotCreateInput;
  connect?: ParkingLotWhereUniqueInput;
}

export interface TrackingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TrackingWhereInput;
  AND?: TrackingSubscriptionWhereInput[] | TrackingSubscriptionWhereInput;
}

export interface AirshowCreateOneInput {
  create?: AirshowCreateInput;
  connect?: AirshowWhereUniqueInput;
}

export interface ParkingLotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ParkingLotWhereInput;
  AND?: ParkingLotSubscriptionWhereInput[] | ParkingLotSubscriptionWhereInput;
}

export type ZoneWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AddressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AddressWhereInput;
  AND?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
}

export interface TrackingCreateInput {
  id: ID_Input;
  createdAt: DateTimeInput;
  updatedAt: DateTimeInput;
  airshow: AirshowCreateOneInput;
  parking_lot?: ParkingLotCreateOneInput;
  zone?: ZoneCreateOneInput;
  vehicle_count: Int;
  bus_count: Int;
  passenger_count: Int;
}

export type ParkingLotWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ParkingLotUpdateManyMutationInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  name?: String;
  vehicle_capacity?: Int;
  estimated_travel_distance?: Int;
  estimated_travel_time?: Int;
}

export interface UserUpdateManyMutationInput {
  id?: ID_Input;
  name?: String;
  email?: String;
  password?: String;
}

export interface ZoneUpsertNestedInput {
  update: ZoneUpdateDataInput;
  create: ZoneCreateInput;
}

export interface ZoneWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  lot_count?: Int;
  lot_count_not?: Int;
  lot_count_in?: Int[] | Int;
  lot_count_not_in?: Int[] | Int;
  lot_count_lt?: Int;
  lot_count_lte?: Int;
  lot_count_gt?: Int;
  lot_count_gte?: Int;
  AND?: ZoneWhereInput[] | ZoneWhereInput;
}

export interface ZoneUpdateDataInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  name?: String;
  lot_count?: Int;
}

export interface UserCreateInput {
  id: ID_Input;
  name: String;
  email: String;
  password: String;
}

export interface ZoneUpdateOneInput {
  create?: ZoneCreateInput;
  update?: ZoneUpdateDataInput;
  upsert?: ZoneUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ZoneWhereUniqueInput;
}

export interface ParkingLotUpsertNestedInput {
  update: ParkingLotUpdateDataInput;
  create: ParkingLotCreateInput;
}

export interface AddressCreateInput {
  id: ID_Input;
  createdAt: DateTimeInput;
  updatedAt: DateTimeInput;
  address_line: String;
  address_line_two?: String;
  zipcode: String;
  city: String;
  state: String;
}

export interface AddressWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  address_line?: String;
  address_line_not?: String;
  address_line_in?: String[] | String;
  address_line_not_in?: String[] | String;
  address_line_lt?: String;
  address_line_lte?: String;
  address_line_gt?: String;
  address_line_gte?: String;
  address_line_contains?: String;
  address_line_not_contains?: String;
  address_line_starts_with?: String;
  address_line_not_starts_with?: String;
  address_line_ends_with?: String;
  address_line_not_ends_with?: String;
  address_line_two?: String;
  address_line_two_not?: String;
  address_line_two_in?: String[] | String;
  address_line_two_not_in?: String[] | String;
  address_line_two_lt?: String;
  address_line_two_lte?: String;
  address_line_two_gt?: String;
  address_line_two_gte?: String;
  address_line_two_contains?: String;
  address_line_two_not_contains?: String;
  address_line_two_starts_with?: String;
  address_line_two_not_starts_with?: String;
  address_line_two_ends_with?: String;
  address_line_two_not_ends_with?: String;
  zipcode?: String;
  zipcode_not?: String;
  zipcode_in?: String[] | String;
  zipcode_not_in?: String[] | String;
  zipcode_lt?: String;
  zipcode_lte?: String;
  zipcode_gt?: String;
  zipcode_gte?: String;
  zipcode_contains?: String;
  zipcode_not_contains?: String;
  zipcode_starts_with?: String;
  zipcode_not_starts_with?: String;
  zipcode_ends_with?: String;
  zipcode_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  AND?: AddressWhereInput[] | AddressWhereInput;
}

export interface AddressUpdateInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  address_line?: String;
  address_line_two?: String;
  zipcode?: String;
  city?: String;
  state?: String;
}

export interface ParkingLotUpdateOneInput {
  create?: ParkingLotCreateInput;
  update?: ParkingLotUpdateDataInput;
  upsert?: ParkingLotUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ParkingLotWhereUniqueInput;
}

export interface AddressUpdateManyMutationInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  address_line?: String;
  address_line_two?: String;
  zipcode?: String;
  city?: String;
  state?: String;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface ZoneUpdateOneRequiredInput {
  create?: ZoneCreateInput;
  update?: ZoneUpdateDataInput;
  upsert?: ZoneUpsertNestedInput;
  connect?: ZoneWhereUniqueInput;
}

export interface ZoneSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ZoneWhereInput;
  AND?: ZoneSubscriptionWhereInput[] | ZoneSubscriptionWhereInput;
}

export interface AddressUpdateManyDataInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  address_line?: String;
  address_line_two?: String;
  zipcode?: String;
  city?: String;
  state?: String;
}

export interface AirshowWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  date?: String;
  date_not?: String;
  date_in?: String[] | String;
  date_not_in?: String[] | String;
  date_lt?: String;
  date_lte?: String;
  date_gt?: String;
  date_gte?: String;
  date_contains?: String;
  date_not_contains?: String;
  date_starts_with?: String;
  date_not_starts_with?: String;
  date_ends_with?: String;
  date_not_ends_with?: String;
  AND?: AirshowWhereInput[] | AirshowWhereInput;
}

export interface AddressUpdateManyWithWhereNestedInput {
  where: AddressScalarWhereInput;
  data: AddressUpdateManyDataInput;
}

export interface ZoneUpdateManyMutationInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  name?: String;
  lot_count?: Int;
}

export interface AirshowUpdateInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  name?: String;
  date?: String;
}

export interface ParkingLotWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  address_some?: AddressWhereInput;
  vehicle_capacity?: Int;
  vehicle_capacity_not?: Int;
  vehicle_capacity_in?: Int[] | Int;
  vehicle_capacity_not_in?: Int[] | Int;
  vehicle_capacity_lt?: Int;
  vehicle_capacity_lte?: Int;
  vehicle_capacity_gt?: Int;
  vehicle_capacity_gte?: Int;
  estimated_travel_distance?: Int;
  estimated_travel_distance_not?: Int;
  estimated_travel_distance_in?: Int[] | Int;
  estimated_travel_distance_not_in?: Int[] | Int;
  estimated_travel_distance_lt?: Int;
  estimated_travel_distance_lte?: Int;
  estimated_travel_distance_gt?: Int;
  estimated_travel_distance_gte?: Int;
  estimated_travel_time?: Int;
  estimated_travel_time_not?: Int;
  estimated_travel_time_in?: Int[] | Int;
  estimated_travel_time_not_in?: Int[] | Int;
  estimated_travel_time_lt?: Int;
  estimated_travel_time_lte?: Int;
  estimated_travel_time_gt?: Int;
  estimated_travel_time_gte?: Int;
  zone?: ZoneWhereInput;
  AND?: ParkingLotWhereInput[] | ParkingLotWhereInput;
}

export interface AirshowUpdateManyMutationInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  name?: String;
  date?: String;
}

export interface TrackingUpdateManyMutationInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  vehicle_count?: Int;
  bus_count?: Int;
  passenger_count?: Int;
}

export interface ParkingLotCreateInput {
  id: ID_Input;
  createdAt: DateTimeInput;
  updatedAt: DateTimeInput;
  name: String;
  address?: AddressCreateManyInput;
  vehicle_capacity: Int;
  estimated_travel_distance?: Int;
  estimated_travel_time?: Int;
  zone: ZoneCreateOneInput;
}

export interface TrackingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  airshow?: AirshowWhereInput;
  parking_lot?: ParkingLotWhereInput;
  zone?: ZoneWhereInput;
  vehicle_count?: Int;
  vehicle_count_not?: Int;
  vehicle_count_in?: Int[] | Int;
  vehicle_count_not_in?: Int[] | Int;
  vehicle_count_lt?: Int;
  vehicle_count_lte?: Int;
  vehicle_count_gt?: Int;
  vehicle_count_gte?: Int;
  bus_count?: Int;
  bus_count_not?: Int;
  bus_count_in?: Int[] | Int;
  bus_count_not_in?: Int[] | Int;
  bus_count_lt?: Int;
  bus_count_lte?: Int;
  bus_count_gt?: Int;
  bus_count_gte?: Int;
  passenger_count?: Int;
  passenger_count_not?: Int;
  passenger_count_in?: Int[] | Int;
  passenger_count_not_in?: Int[] | Int;
  passenger_count_lt?: Int;
  passenger_count_lte?: Int;
  passenger_count_gt?: Int;
  passenger_count_gte?: Int;
  AND?: TrackingWhereInput[] | TrackingWhereInput;
}

export interface AddressCreateManyInput {
  create?: AddressCreateInput[] | AddressCreateInput;
  connect?: AddressWhereUniqueInput[] | AddressWhereUniqueInput;
}

export interface AirshowUpsertNestedInput {
  update: AirshowUpdateDataInput;
  create: AirshowCreateInput;
}

export interface AddressScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  address_line?: String;
  address_line_not?: String;
  address_line_in?: String[] | String;
  address_line_not_in?: String[] | String;
  address_line_lt?: String;
  address_line_lte?: String;
  address_line_gt?: String;
  address_line_gte?: String;
  address_line_contains?: String;
  address_line_not_contains?: String;
  address_line_starts_with?: String;
  address_line_not_starts_with?: String;
  address_line_ends_with?: String;
  address_line_not_ends_with?: String;
  address_line_two?: String;
  address_line_two_not?: String;
  address_line_two_in?: String[] | String;
  address_line_two_not_in?: String[] | String;
  address_line_two_lt?: String;
  address_line_two_lte?: String;
  address_line_two_gt?: String;
  address_line_two_gte?: String;
  address_line_two_contains?: String;
  address_line_two_not_contains?: String;
  address_line_two_starts_with?: String;
  address_line_two_not_starts_with?: String;
  address_line_two_ends_with?: String;
  address_line_two_not_ends_with?: String;
  zipcode?: String;
  zipcode_not?: String;
  zipcode_in?: String[] | String;
  zipcode_not_in?: String[] | String;
  zipcode_lt?: String;
  zipcode_lte?: String;
  zipcode_gt?: String;
  zipcode_gte?: String;
  zipcode_contains?: String;
  zipcode_not_contains?: String;
  zipcode_starts_with?: String;
  zipcode_not_starts_with?: String;
  zipcode_ends_with?: String;
  zipcode_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  AND?: AddressScalarWhereInput[] | AddressScalarWhereInput;
  OR?: AddressScalarWhereInput[] | AddressScalarWhereInput;
  NOT?: AddressScalarWhereInput[] | AddressScalarWhereInput;
}

export type AirshowWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ZoneCreateInput {
  id: ID_Input;
  createdAt: DateTimeInput;
  updatedAt: DateTimeInput;
  name: String;
  lot_count: Int;
}

export interface ZoneUpdateInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  name?: String;
  lot_count?: Int;
}

export interface AddressUpdateDataInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  address_line?: String;
  address_line_two?: String;
  zipcode?: String;
  city?: String;
  state?: String;
}

export interface AddressUpdateWithWhereUniqueNestedInput {
  where: AddressWhereUniqueInput;
  data: AddressUpdateDataInput;
}

export interface AddressUpdateManyInput {
  create?: AddressCreateInput[] | AddressCreateInput;
  update?:
    | AddressUpdateWithWhereUniqueNestedInput[]
    | AddressUpdateWithWhereUniqueNestedInput;
  upsert?:
    | AddressUpsertWithWhereUniqueNestedInput[]
    | AddressUpsertWithWhereUniqueNestedInput;
  delete?: AddressWhereUniqueInput[] | AddressWhereUniqueInput;
  connect?: AddressWhereUniqueInput[] | AddressWhereUniqueInput;
  set?: AddressWhereUniqueInput[] | AddressWhereUniqueInput;
  disconnect?: AddressWhereUniqueInput[] | AddressWhereUniqueInput;
  deleteMany?: AddressScalarWhereInput[] | AddressScalarWhereInput;
  updateMany?:
    | AddressUpdateManyWithWhereNestedInput[]
    | AddressUpdateManyWithWhereNestedInput;
}

export interface ParkingLotUpdateInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  name?: String;
  address?: AddressUpdateManyInput;
  vehicle_capacity?: Int;
  estimated_travel_distance?: Int;
  estimated_travel_time?: Int;
  zone?: ZoneUpdateOneRequiredInput;
}

export interface UserUpdateInput {
  id?: ID_Input;
  name?: String;
  email?: String;
  password?: String;
}

export interface AirshowSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AirshowWhereInput;
  AND?: AirshowSubscriptionWhereInput[] | AirshowSubscriptionWhereInput;
}

export interface AirshowUpdateDataInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  name?: String;
  date?: String;
}

export interface ParkingLotUpdateDataInput {
  id?: ID_Input;
  createdAt?: DateTimeInput;
  updatedAt?: DateTimeInput;
  name?: String;
  address?: AddressUpdateManyInput;
  vehicle_capacity?: Int;
  estimated_travel_distance?: Int;
  estimated_travel_time?: Int;
  zone?: ZoneUpdateOneRequiredInput;
}

export type TrackingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface ZonePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  lot_count: Int;
}

export interface ZonePreviousValuesPromise
  extends Promise<ZonePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  lot_count: () => Promise<Int>;
}

export interface ZonePreviousValuesSubscription
  extends Promise<AsyncIterator<ZonePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  lot_count: () => Promise<AsyncIterator<Int>>;
}

export interface Zone {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  lot_count: Int;
}

export interface ZonePromise extends Promise<Zone>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  lot_count: () => Promise<Int>;
}

export interface ZoneSubscription
  extends Promise<AsyncIterator<Zone>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  lot_count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ParkingLot {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  vehicle_capacity: Int;
  estimated_travel_distance?: Int;
  estimated_travel_time?: Int;
}

export interface ParkingLotPromise extends Promise<ParkingLot>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  address: <T = FragmentableArray<Address>>(
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vehicle_capacity: () => Promise<Int>;
  estimated_travel_distance: () => Promise<Int>;
  estimated_travel_time: () => Promise<Int>;
  zone: <T = ZonePromise>() => T;
}

export interface ParkingLotSubscription
  extends Promise<AsyncIterator<ParkingLot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  address: <T = Promise<AsyncIterator<AddressSubscription>>>(
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vehicle_capacity: () => Promise<AsyncIterator<Int>>;
  estimated_travel_distance: () => Promise<AsyncIterator<Int>>;
  estimated_travel_time: () => Promise<AsyncIterator<Int>>;
  zone: <T = ZoneSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ZoneEdge {
  node: Zone;
  cursor: String;
}

export interface ZoneEdgePromise extends Promise<ZoneEdge>, Fragmentable {
  node: <T = ZonePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ZoneEdgeSubscription
  extends Promise<AsyncIterator<ZoneEdge>>,
    Fragmentable {
  node: <T = ZoneSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAirshow {
  count: Int;
}

export interface AggregateAirshowPromise
  extends Promise<AggregateAirshow>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAirshowSubscription
  extends Promise<AsyncIterator<AggregateAirshow>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ZoneSubscriptionPayload {
  mutation: MutationType;
  node: Zone;
  updatedFields: String[];
  previousValues: ZonePreviousValues;
}

export interface ZoneSubscriptionPayloadPromise
  extends Promise<ZoneSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ZonePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ZonePreviousValuesPromise>() => T;
}

export interface ZoneSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ZoneSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ZoneSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ZonePreviousValuesSubscription>() => T;
}

export interface AirshowEdge {
  node: Airshow;
  cursor: String;
}

export interface AirshowEdgePromise extends Promise<AirshowEdge>, Fragmentable {
  node: <T = AirshowPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AirshowEdgeSubscription
  extends Promise<AsyncIterator<AirshowEdge>>,
    Fragmentable {
  node: <T = AirshowSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Address {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  address_line: String;
  address_line_two?: String;
  zipcode: String;
  city: String;
  state: String;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  address_line: () => Promise<String>;
  address_line_two: () => Promise<String>;
  zipcode: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  address_line: () => Promise<AsyncIterator<String>>;
  address_line_two: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface AggregateTracking {
  count: Int;
}

export interface AggregateTrackingPromise
  extends Promise<AggregateTracking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrackingSubscription
  extends Promise<AsyncIterator<AggregateTracking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  address_line: String;
  address_line_two?: String;
  zipcode: String;
  city: String;
  state: String;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  address_line: () => Promise<String>;
  address_line_two: () => Promise<String>;
  zipcode: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  address_line: () => Promise<AsyncIterator<String>>;
  address_line_two: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
}

export interface TrackingConnection {
  pageInfo: PageInfo;
  edges: TrackingEdge[];
}

export interface TrackingConnectionPromise
  extends Promise<TrackingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrackingEdge>>() => T;
  aggregate: <T = AggregateTrackingPromise>() => T;
}

export interface TrackingConnectionSubscription
  extends Promise<AsyncIterator<TrackingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrackingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrackingSubscription>() => T;
}

export interface AirshowConnection {
  pageInfo: PageInfo;
  edges: AirshowEdge[];
}

export interface AirshowConnectionPromise
  extends Promise<AirshowConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AirshowEdge>>() => T;
  aggregate: <T = AggregateAirshowPromise>() => T;
}

export interface AirshowConnectionSubscription
  extends Promise<AsyncIterator<AirshowConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AirshowEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAirshowSubscription>() => T;
}

export interface AggregateParkingLot {
  count: Int;
}

export interface AggregateParkingLotPromise
  extends Promise<AggregateParkingLot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParkingLotSubscription
  extends Promise<AsyncIterator<AggregateParkingLot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AirshowSubscriptionPayload {
  mutation: MutationType;
  node: Airshow;
  updatedFields: String[];
  previousValues: AirshowPreviousValues;
}

export interface AirshowSubscriptionPayloadPromise
  extends Promise<AirshowSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AirshowPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AirshowPreviousValuesPromise>() => T;
}

export interface AirshowSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AirshowSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AirshowSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AirshowPreviousValuesSubscription>() => T;
}

export interface ParkingLotConnection {
  pageInfo: PageInfo;
  edges: ParkingLotEdge[];
}

export interface ParkingLotConnectionPromise
  extends Promise<ParkingLotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParkingLotEdge>>() => T;
  aggregate: <T = AggregateParkingLotPromise>() => T;
}

export interface ParkingLotConnectionSubscription
  extends Promise<AsyncIterator<ParkingLotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParkingLotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParkingLotSubscription>() => T;
}

export interface AirshowPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  date: String;
}

export interface AirshowPreviousValuesPromise
  extends Promise<AirshowPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  date: () => Promise<String>;
}

export interface AirshowPreviousValuesSubscription
  extends Promise<AsyncIterator<AirshowPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<String>>;
}

export interface ZoneConnection {
  pageInfo: PageInfo;
  edges: ZoneEdge[];
}

export interface ZoneConnectionPromise
  extends Promise<ZoneConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ZoneEdge>>() => T;
  aggregate: <T = AggregateZonePromise>() => T;
}

export interface ZoneConnectionSubscription
  extends Promise<AsyncIterator<ZoneConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ZoneEdgeSubscription>>>() => T;
  aggregate: <T = AggregateZoneSubscription>() => T;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ParkingLotSubscriptionPayload {
  mutation: MutationType;
  node: ParkingLot;
  updatedFields: String[];
  previousValues: ParkingLotPreviousValues;
}

export interface ParkingLotSubscriptionPayloadPromise
  extends Promise<ParkingLotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParkingLotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParkingLotPreviousValuesPromise>() => T;
}

export interface ParkingLotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParkingLotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParkingLotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParkingLotPreviousValuesSubscription>() => T;
}

export interface TrackingEdge {
  node: Tracking;
  cursor: String;
}

export interface TrackingEdgePromise
  extends Promise<TrackingEdge>,
    Fragmentable {
  node: <T = TrackingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrackingEdgeSubscription
  extends Promise<AsyncIterator<TrackingEdge>>,
    Fragmentable {
  node: <T = TrackingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ParkingLotEdge {
  node: ParkingLot;
  cursor: String;
}

export interface ParkingLotEdgePromise
  extends Promise<ParkingLotEdge>,
    Fragmentable {
  node: <T = ParkingLotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParkingLotEdgeSubscription
  extends Promise<AsyncIterator<ParkingLotEdge>>,
    Fragmentable {
  node: <T = ParkingLotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TrackingPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  vehicle_count: Int;
  bus_count: Int;
  passenger_count: Int;
}

export interface TrackingPreviousValuesPromise
  extends Promise<TrackingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  vehicle_count: () => Promise<Int>;
  bus_count: () => Promise<Int>;
  passenger_count: () => Promise<Int>;
}

export interface TrackingPreviousValuesSubscription
  extends Promise<AsyncIterator<TrackingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  vehicle_count: () => Promise<AsyncIterator<Int>>;
  bus_count: () => Promise<AsyncIterator<Int>>;
  passenger_count: () => Promise<AsyncIterator<Int>>;
}

export interface TrackingSubscriptionPayload {
  mutation: MutationType;
  node: Tracking;
  updatedFields: String[];
  previousValues: TrackingPreviousValues;
}

export interface TrackingSubscriptionPayloadPromise
  extends Promise<TrackingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrackingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrackingPreviousValuesPromise>() => T;
}

export interface TrackingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrackingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrackingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrackingPreviousValuesSubscription>() => T;
}

export interface Airshow {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  date: String;
}

export interface AirshowPromise extends Promise<Airshow>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  date: () => Promise<String>;
}

export interface AirshowSubscription
  extends Promise<AsyncIterator<Airshow>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<String>>;
}

export interface ParkingLotPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  vehicle_capacity: Int;
  estimated_travel_distance?: Int;
  estimated_travel_time?: Int;
}

export interface ParkingLotPreviousValuesPromise
  extends Promise<ParkingLotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  vehicle_capacity: () => Promise<Int>;
  estimated_travel_distance: () => Promise<Int>;
  estimated_travel_time: () => Promise<Int>;
}

export interface ParkingLotPreviousValuesSubscription
  extends Promise<AsyncIterator<ParkingLotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  vehicle_capacity: () => Promise<AsyncIterator<Int>>;
  estimated_travel_distance: () => Promise<AsyncIterator<Int>>;
  estimated_travel_time: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateZone {
  count: Int;
}

export interface AggregateZonePromise
  extends Promise<AggregateZone>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateZoneSubscription
  extends Promise<AsyncIterator<AggregateZone>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Tracking {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  vehicle_count: Int;
  bus_count: Int;
  passenger_count: Int;
}

export interface TrackingPromise extends Promise<Tracking>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  airshow: <T = AirshowPromise>() => T;
  parking_lot: <T = ParkingLotPromise>() => T;
  zone: <T = ZonePromise>() => T;
  vehicle_count: () => Promise<Int>;
  bus_count: () => Promise<Int>;
  passenger_count: () => Promise<Int>;
}

export interface TrackingSubscription
  extends Promise<AsyncIterator<Tracking>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  airshow: <T = AirshowSubscription>() => T;
  parking_lot: <T = ParkingLotSubscription>() => T;
  zone: <T = ZoneSubscription>() => T;
  vehicle_count: () => Promise<AsyncIterator<Int>>;
  bus_count: () => Promise<AsyncIterator<Int>>;
  passenger_count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Airshow",
    embedded: false
  },
  {
    name: "Zone",
    embedded: false
  },
  {
    name: "ParkingLot",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "Tracking",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
